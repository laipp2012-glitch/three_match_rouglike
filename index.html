
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji Rogue: Evolution</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background: #020617; color: white; margin: 0; overflow: hidden; touch-action: none; }
        .grid-bg { background-image: radial-gradient(circle, #1e293b 1px, transparent 1px); background-size: 30px 30px; }
        @keyframes pulse-glow { 0%, 100% { opacity: 0.5; transform: scale(1); } 50% { opacity: 1; transform: scale(1.1); } }
        .bonus-glow { animation: pulse-glow 2s infinite; }
        .tile-pop { animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes pop { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        .particle { pointer-events: none; position: absolute; border-radius: 50%; }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;

        // --- –ö–û–ù–°–¢–ê–ù–¢–´ ---
        const GRID_SIZE = 8;
        const INITIAL_HP = 100;
        const ATTACK_INTERVAL = 10;
        const EMOJIS = ['üçé', 'üçä', 'üçã', 'üçá', 'ü•ù'];
        const MODIFIERS = { FIRE: 'fire', LIGHTNING: 'lightning', STAR: 'star', NONE: 'none' };
        
        const ENEMIES = [
            { name: '–õ–µ—Å–Ω–æ–π –°–ª–∏–∑–µ–Ω—å', emoji: 'ü´†', hp: 600, damage: 15 },
            { name: '–¢–µ–Ω–µ–≤–æ–π –î—É—Ö', emoji: 'üëª', hp: 1500, damage: 20 },
            { name: '–û–≥–Ω–µ–Ω–Ω—ã–π –î–µ–º–æ–Ω', emoji: 'üòà', hp: 3500, damage: 25 },
            { name: '–î—Ä–µ–≤–Ω–∏–π –î—Ä–∞–∫–æ–Ω', emoji: 'üê≤', hp: 8000, damage: 40 }
        ];

        const PERKS = [
            { id: 'vampire', name: '–í–∞–º–ø–∏—Ä–∏–∑–º', desc: '–Ø–±–ª–æ–∫–∏ üçé –ª–µ—á–∞—Ç +5 HP', icon: 'üßõ' },
            { id: 'pyro', name: '–ü–∏—Ä–æ–º–∞–Ω—Ç–∏—è', desc: '–ë–æ–º–±—ã üî• –±—å—é—Ç –≤ 2 —Ä–∞–∑–∞ —Å–∏–ª—å–Ω–µ–µ', icon: 'üî•' },
            { id: 'tank', name: '–ë—Ä–æ–Ω—è', desc: '+50 –∫ –ú–∞–∫—Å. HP', icon: 'üõ°Ô∏è' },
            { id: 'lucky', name: '–£–¥–∞—á–∞', desc: '–ö–æ–º–±–æ –¥–∞—é—Ç +50% —É—Ä–æ–Ω–∞', icon: 'üçÄ' }
        ];

        // --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---
        const getRandomEmoji = () => EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
        
        const createTile = (emoji = getRandomEmoji(), modifier = MODIFIERS.NONE) => ({
            emoji, modifier, id: Math.random().toString(36).substr(2, 9)
        });

        const createInitialGrid = () => {
            let grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    let emoji;
                    do { emoji = getRandomEmoji(); } 
                    while ((r >= 2 && grid[r-1][c].emoji === emoji && grid[r-2][c].emoji === emoji) || 
                           (c >= 2 && grid[r][c-1].emoji === emoji && grid[r][c-2].emoji === emoji));
                    grid[r][c] = createTile(emoji);
                }
            }
            return grid;
        };

        // --- –ö–û–ú–ü–û–ù–ï–ù–¢ –ß–ê–°–¢–ò–¶ ---
        const Particles = ({ x, y, color }) => {
            const [parts] = useState(() => Array(8).fill(0).map(() => ({
                id: Math.random(),
                tx: (Math.random() - 0.5) * 100,
                ty: (Math.random() - 0.5) * 100,
                s: Math.random() * 6 + 2
            })));

            return (
                <div className="absolute inset-0 pointer-events-none z-50 overflow-visible">
                    {parts.map(p => (
                        <div key={p.id} className="particle bg-white opacity-0 animate-ping"
                             style={{
                                 left: x, top: y, width: p.s, height: p.s,
                                 backgroundColor: color,
                                 transform: `translate(${p.tx}px, ${p.ty}px)`
                             }} 
                        />
                    ))}
                </div>
            );
        };

        // --- –û–°–ù–û–í–ù–û–ï –ü–†–ò–õ–û–ñ–ï–ù–ò–ï ---
        const App = () => {
            const [grid, setGrid] = useState(createInitialGrid());
            const [view, setView] = useState('start');
            const [selected, setSelected] = useState(null);
            const [playerHp, setPlayerHp] = useState(INITIAL_HP);
            const [playerMaxHp, setPlayerMaxHp] = useState(INITIAL_HP);
            const [enemyHp, setEnemyHp] = useState(ENEMIES[0].hp);
            const [maxEnemyHp, setMaxEnemyHp] = useState(ENEMIES[0].hp);
            const [floor, setFloor] = useState(1);
            const [moves, setMoves] = useState(ATTACK_INTERVAL);
            const [activePerks, setActivePerks] = useState([]);
            const [isAnimating, setIsAnimating] = useState(false);
            const [combo, setCombo] = useState(0);

            const currentEnemy = ENEMIES[(floor - 1) % ENEMIES.length];

            // –ü–æ–∏—Å–∫ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
            const findMatches = (currentGrid) => {
                let matchedPositions = new Set();
                let results = [];

                // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ
                for (let r = 0; r < GRID_SIZE; r++) {
                    let count = 1;
                    for (let c = 1; c <= GRID_SIZE; c++) {
                        if (c < GRID_SIZE && currentGrid[r][c].emoji === currentGrid[r][c-1].emoji) count++;
                        else {
                            if (count >= 3) {
                                let match = [];
                                for (let i = 1; i <= count; i++) match.push({r, c: c-i});
                                results.push({ type: 'row', tiles: match });
                            }
                            count = 1;
                        }
                    }
                }
                // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
                for (let c = 0; c < GRID_SIZE; c++) {
                    let count = 1;
                    for (let r = 1; r <= GRID_SIZE; r++) {
                        if (r < GRID_SIZE && currentGrid[r][c].emoji === currentGrid[r-1][c].emoji) count++;
                        else {
                            if (count >= 3) {
                                let match = [];
                                for (let i = 1; i <= count; i++) match.push({r: r-i, c});
                                results.push({ type: 'col', tiles: match });
                            }
                            count = 1;
                        }
                    }
                }
                return results;
            };

            const triggerModifier = async (r, c, modifier, emoji, tempGrid) => {
                let affected = [{r, c}];
                if (modifier === MODIFIERS.FIRE) {
                    for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
                        let nr=r+i, nc=c+j;
                        if(nr>=0 && nr<GRID_SIZE && nc>=0 && nc<GRID_SIZE) affected.push({r:nr, c:nc});
                    }
                } else if (modifier === MODIFIERS.LIGHTNING) {
                    for(let i=0; i<GRID_SIZE; i++) {
                        affected.push({r: i, c});
                        affected.push({r, c: i});
                    }
                } else if (modifier === MODIFIERS.STAR) {
                    for(let i=0; i<GRID_SIZE; i++) for(let j=0; j<GRID_SIZE; j++) {
                        if(tempGrid[i][j].emoji === emoji) affected.push({r:i, c:j});
                    }
                }
                return affected;
            };

            const processTurn = async (currentGrid, lastSwap = null) => {
                const matches = findMatches(currentGrid);
                if (matches.length === 0) {
                    setCombo(0);
                    return false;
                }

                setIsAnimating(true);
                let newGrid = currentGrid.map(row => [...row]);
                let allMatched = [];
                let bonusesToCreate = [];

                matches.forEach(m => {
                    allMatched.push(...m.tiles);
                    if (m.tiles.length === 4) bonusesToCreate.push({ ...m.tiles[0], type: MODIFIERS.FIRE });
                    if (m.tiles.length >= 5) bonusesToCreate.push({ ...m.tiles[0], type: MODIFIERS.STAR });
                });

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è (–º–æ–ª–Ω–∏–∏)
                let posMap = {};
                allMatched.forEach(p => {
                    let key = `${p.r},${p.c}`;
                    posMap[key] = (posMap[key] || 0) + 1;
                    if (posMap[key] > 1) bonusesToCreate.push({ r: p.r, c: p.c, type: MODIFIERS.LIGHTNING });
                });

                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤ –≤ –∑–æ–Ω–µ –≤–∑—Ä—ã–≤–∞
                let finalClear = [...allMatched];
                for (let p of allMatched) {
                    if (newGrid[p.r][p.c].modifier !== MODIFIERS.NONE) {
                        let extra = await triggerModifier(p.r, p.c, newGrid[p.r][p.c].modifier, newGrid[p.r][p.c].emoji, newGrid);
                        finalClear.push(...extra);
                    }
                }

                // –£–†–û–ù –ò –ü–ï–†–ö–ò
                let totalDamage = finalClear.length * 10;
                if (activePerks.includes('lucky')) totalDamage *= 1.5;
                
                finalClear.forEach(p => {
                    if (newGrid[p.r][p.c].emoji === 'üçé' && activePerks.includes('vampire')) {
                        setPlayerHp(h => Math.min(playerMaxHp, h + 1));
                    }
                });

                setEnemyHp(h => Math.max(0, h - totalDamage));

                // –û—á–∏—Å—Ç–∫–∞ –∏ –ø–∞–¥–µ–Ω–∏–µ
                finalClear.forEach(p => { if(newGrid[p.r][p.c]) newGrid[p.r][p.c] = { emoji: '', modifier: MODIFIERS.NONE } });
                
                // –°–æ–∑–¥–∞–Ω–∏–µ –±–æ–Ω—É—Å–æ–≤
                bonusesToCreate.forEach(b => {
                    newGrid[b.r][b.c] = createTile(getRandomEmoji(), b.type);
                });

                setGrid([...newGrid]);
                await new Promise(r => setTimeout(r, 300));

                // –ü–∞–¥–µ–Ω–∏–µ
                for (let c = 0; c < GRID_SIZE; c++) {
                    let empty = 0;
                    for (let r = GRID_SIZE - 1; r >= 0; r--) {
                        if (newGrid[r][c].emoji === '') empty++;
                        else if (empty > 0) {
                            newGrid[r + empty][c] = newGrid[r][c];
                            newGrid[r][c] = { emoji: '', modifier: MODIFIERS.NONE };
                        }
                    }
                    for (let r = 0; r < empty; r++) newGrid[r][c] = createTile();
                }

                setGrid([...newGrid]);
                await new Promise(r => setTimeout(r, 200));
                
                await processTurn(newGrid);
                setIsAnimating(false);
                return true;
            };

            const handleTileClick = async (r, c) => {
                if (isAnimating || view !== 'playing') return;
                if (!selected) {
                    setSelected({r, c});
                } else {
                    const isAdj = Math.abs(selected.r - r) + Math.abs(selected.c - c) === 1;
                    if (isAdj) {
                        let newGrid = grid.map(row => [...row]);
                        [newGrid[selected.r][selected.c], newGrid[r][c]] = [newGrid[r][c], newGrid[selected.r][selected.c]];
                        
                        setGrid(newGrid);
                        const matched = await processTurn(newGrid, {r, c});
                        
                        if (!matched) {
                            setTimeout(() => setGrid(grid), 250);
                        } else {
                            setMoves(m => {
                                if (m <= 1) {
                                    setPlayerHp(hp => Math.max(0, hp - currentEnemy.damage));
                                    return ATTACK_INTERVAL;
                                }
                                return m - 1;
                            });
                        }
                    }
                    setSelected(null);
                }
            };

            const addPerk = (perkId) => {
                setActivePerks([...activePerks, perkId]);
                if (perkId === 'tank') setPlayerMaxHp(h => h + 50);
                nextFloor();
            };

            const nextFloor = () => {
                const nF = floor + 1;
                setFloor(nF);
                const enemy = ENEMIES[(nF - 1) % ENEMIES.length];
                const hpScale = enemy.hp * (1 + (nF - 1) * 0.4);
                setEnemyHp(hpScale);
                setMaxEnemyHp(hpScale);
                setMoves(ATTACK_INTERVAL);
                setGrid(createInitialGrid());
                setView('playing');
            };

            useEffect(() => {
                if (enemyHp <= 0 && view === 'playing') setView('reward');
                if (playerHp <= 0 && view === 'playing') setView('gameOver');
            }, [enemyHp, playerHp, view]);

            if (view === 'start') return (
                <div className="flex flex-col items-center justify-center min-h-screen p-6 text-center grid-bg">
                    <h1 className="text-7xl font-black mb-4 tracking-tighter bg-gradient-to-br from-indigo-400 to-purple-600 bg-clip-text text-transparent">EMOJI ROGUE</h1>
                    <p className="text-slate-400 mb-12 text-lg">–£–Ω–∏—á—Ç–æ–∂–∞–π –º–æ–Ω—Å—Ç—Ä–æ–≤, —Å–æ–±–∏—Ä–∞–π –±–æ–Ω—É—Å—ã, –≤—ã–±–∏—Ä–∞–π –ø–µ—Ä–∫–∏!</p>
                    <button onClick={() => setView('playing')} className="px-16 py-5 bg-indigo-600 rounded-3xl font-black text-2xl shadow-2xl hover:bg-indigo-500 transition-all active:scale-95">–ù–ê–ß–ê–¢–¨ –ü–†–ò–ö–õ–Æ–ß–ï–ù–ò–ï</button>
                </div>
            );

            if (view === 'reward') return (
                <div className="flex flex-col items-center justify-center min-h-screen p-6 grid-bg">
                    <div className="text-6xl mb-6">üéÅ</div>
                    <h2 className="text-4xl font-black mb-2">–ü–û–ë–ï–î–ê!</h2>
                    <p className="text-slate-400 mb-10 text-center">–í—ã–±–µ—Ä–∏—Ç–µ —É—Å–∏–ª–µ–Ω–∏–µ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —ç—Ç–∞–∂–∞:</p>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 w-full max-w-md">
                        {PERKS.slice(0, 3).map(perk => (
                            <button key={perk.id} onClick={() => addPerk(perk.id)} className="bg-slate-900 border border-white/10 p-6 rounded-3xl hover:bg-indigo-900/40 transition-all text-left group">
                                <div className="text-3xl mb-3 group-hover:scale-125 transition-transform">{perk.icon}</div>
                                <div className="font-bold text-lg">{perk.name}</div>
                                <div className="text-sm text-slate-500">{perk.desc}</div>
                            </button>
                        ))}
                    </div>
                </div>
            );

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-4 select-none grid-bg">
                    <div className="w-full max-w-md bg-slate-900/80 backdrop-blur-3xl border border-white/10 rounded-[3.5rem] p-6 shadow-2xl relative">
                        
                        {/* Enemy UI */}
                        <div className="flex justify-between items-end mb-4">
                            <div>
                                <div className="text-[10px] uppercase font-black text-slate-500 tracking-widest mb-1">–≠—Ç–∞–∂ {floor}</div>
                                <div className="text-2xl font-black">{currentEnemy.name}</div>
                            </div>
                            <div className="text-5xl animate-bounce">{currentEnemy.emoji}</div>
                        </div>

                        <div className="w-full h-4 bg-slate-800 rounded-full mb-8 overflow-hidden border border-white/5 shadow-inner">
                            <div className="h-full bg-gradient-to-r from-red-600 to-orange-500 transition-all duration-500" style={{width: `${(enemyHp/maxEnemyHp)*100}%`}} />
                        </div>

                        {/* Board */}
                        <div className="grid grid-cols-8 gap-1.5 p-2 bg-black/40 rounded-[2.5rem] border border-white/5 shadow-inner mb-8 relative">
                            {grid.map((row, r) => row.map((tile, c) => (
                                <div key={tile.id} onClick={() => handleTileClick(r, c)}
                                    className={`aspect-square flex items-center justify-center text-xl sm:text-2xl cursor-pointer rounded-xl transition-all duration-150 relative
                                        ${selected?.r === r && selected?.c === c ? 'bg-white/20 ring-4 ring-white scale-110 z-10' : 'hover:bg-white/5 active:scale-90'}
                                        ${tile.modifier === MODIFIERS.FIRE ? 'ring-2 ring-red-500 bg-red-500/10' : ''}
                                        ${tile.modifier === MODIFIERS.LIGHTNING ? 'ring-2 ring-blue-500 bg-blue-500/10' : ''}
                                        ${tile.modifier === MODIFIERS.STAR ? 'ring-2 ring-yellow-400 bg-yellow-400/10' : ''}`}>
                                    
                                    <span className="tile-pop">{tile.emoji}</span>
                                    
                                    {tile.modifier !== MODIFIERS.NONE && (
                                        <div className="absolute inset-0 bonus-glow rounded-xl flex items-center justify-center opacity-30">
                                            {tile.modifier === MODIFIERS.FIRE && 'üî•'}
                                            {tile.modifier === MODIFIERS.LIGHTNING && '‚ö°'}
                                            {tile.modifier === MODIFIERS.STAR && 'üåü'}
                                        </div>
                                    )}
                                </div>
                            )))}
                        </div>

                        {/* Stats */}
                        <div className="grid grid-cols-2 gap-4">
                            <div className="bg-slate-800/40 p-4 rounded-3xl border border-white/5">
                                <div className="text-[10px] uppercase font-black text-slate-500 mb-1">–ó–¥–æ—Ä–æ–≤—å–µ –≥–µ—Ä–æ—è</div>
                                <div className="text-xl font-black text-emerald-400">{Math.ceil(playerHp)} HP</div>
                                <div className="w-full h-1.5 bg-slate-900 rounded-full mt-2 overflow-hidden">
                                    <div className="h-full bg-emerald-500 transition-all" style={{width: `${(playerHp/playerMaxHp)*100}%`}} />
                                </div>
                            </div>
                            <div className="bg-slate-800/40 p-4 rounded-3xl border border-white/5">
                                <div className="text-[10px] uppercase font-black text-slate-500 mb-1">–£–¥–∞—Ä –º–æ–Ω—Å—Ç—Ä–∞</div>
                                <div className="text-xl font-black text-indigo-400">{moves} —Ö–æ–¥–æ–≤</div>
                                <div className="flex gap-1 mt-2">
                                    {[...Array(ATTACK_INTERVAL)].map((_, i) => (
                                        <div key={i} className={`h-1.5 flex-1 rounded-full ${i < moves ? 'bg-indigo-500' : 'bg-slate-700'}`} />
                                    ))}
                                </div>
                            </div>
                        </div>

                        {view === 'gameOver' && (
                            <div className="absolute inset-0 bg-red-950/95 backdrop-blur-xl z-50 flex flex-col items-center justify-center p-10 text-center rounded-[3.5rem] animate-pop">
                                <div className="text-7xl mb-6">üíÄ</div>
                                <h2 className="text-4xl font-black mb-4">–ö–û–ù–ï–¶ –ò–ì–†–´</h2>
                                <p className="text-red-200/70 mb-10">–í–∞—à–µ –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–∫–æ–Ω—á–∏–ª–æ—Å—å –Ω–∞ {floor} —ç—Ç–∞–∂–µ.</p>
                                <button onClick={() => window.location.reload()} className="w-full py-5 bg-white text-red-950 rounded-3xl font-black text-xl hover:bg-red-50 transition-all shadow-xl">–ü–û–ü–†–û–ë–û–í–ê–¢–¨ –°–ù–û–í–ê</button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
